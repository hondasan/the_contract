<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>THE CONTRACT - PROFESSIONAL -</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Share Tech Mono', 'Courier New', monospace;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
            color: #ccc;
        }
        canvas {
            display: block;
            cursor: none;
            touch-action: none;
        }
        
        #noise-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.08'/%3E%3C/svg%3E");
            opacity: 0.4;
            z-index: 5;
        }

        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            text-shadow: 0 0 5px rgba(0,0,0,0.8);
            z-index: 20;
        }

        /* 依頼書 */
        .message-box {
            background: #080808;
            border: 1px solid #333;
            border-left: 4px solid #d22;
            padding: 30px;
            width: 85%;
            max-width: 650px;
            display: none;
            pointer-events: auto;
            box-shadow: 0 20px 50px rgba(0,0,0,0.9);
            position: relative;
            cursor: pointer;
        }
        .message-box::before {
            content: "CLASSIFIED // EYES ONLY";
            position: absolute;
            top: -12px; right: 10px;
            background: #d22;
            color: #000;
            font-size: 0.7rem;
            padding: 2px 8px;
            font-weight: bold;
            letter-spacing: 2px;
        }
        .message-box.active { display: block; animation: slideIn 0.4s cubic-bezier(0.2, 0.8, 0.2, 1); }
        
        @keyframes slideIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }

        h1 {
            color: #eee;
            margin: 0 0 20px 0;
            font-size: 2rem;
            letter-spacing: 0.1em;
            border-bottom: 1px solid #444;
            padding-bottom: 10px;
            text-transform: uppercase;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        h2 {
            color: #888;
            margin: 15px 0 5px 0;
            font-size: 0.8rem;
            letter-spacing: 0.2em;
        }
        .mission-detail {
            color: #ccc;
            font-size: 1.1rem;
            line-height: 1.6;
            margin-bottom: 20px;
            white-space: pre-wrap;
            min-height: 3em;
            font-weight: normal;
        }
        
        /* ステージ選択ボタン */
        .nav-btn {
            color: #444;
            cursor: pointer;
            font-size: 1.5rem;
            padding: 0 15px;
            transition: color 0.2s;
            user-select: none;
        }
        .nav-btn:hover { color: #d22; }

        /* ハイスコア表示 */
        .highscore-info {
            font-size: 0.8rem;
            color: #4aa;
            margin-top: -15px;
            margin-bottom: 20px;
            text-align: right;
            border-top: 1px dashed #333;
            padding-top: 5px;
            font-family: 'Courier New', monospace;
        }
        .highscore-val { color: #fff; font-weight: bold; margin-left: 10px; }

        .typing::after {
            content: "_";
            color: #d22;
            animation: blink 0.1s step-end infinite;
        }
        .typing.done::after { animation: blink 1s step-end infinite; }
        @keyframes blink { 50% { opacity: 0; } }

        .btn {
            display: inline-block;
            background: #111;
            border: 1px solid #444;
            padding: 15px 50px;
            color: #666;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 1rem;
            letter-spacing: 0.2em;
            margin-top: 15px;
            text-transform: uppercase;
        }
        .btn:hover { background: #d22; color: #fff; border-color: #d22; }
        .btn.disabled { opacity: 0.3; pointer-events: none; }

        /* HUD */
        .hud-info {
            position: absolute;
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.6);
            font-weight: bold;
            pointer-events: none;
            letter-spacing: 1px;
        }
        #bpm-display {
            top: 30px; 
            right: 40px;
            text-align: right;
        }
        #bpm-value { font-size: 3rem; color: #ccc; font-family: 'Courier New', monospace; }
        .bpm-danger #bpm-value { color: #f44; animation: shake 0.2s infinite; }
        @keyframes shake { 0% { transform: translate(0,0); } 25% { transform: translate(1px,1px); } 75% { transform: translate(-1px,-1px); } }

        #wind-display {
            top: 30px; 
            left: 40px;
            text-align: left;
        }
        #wind-value { font-size: 1.5rem; color: #8c8; }
        
        #alert-display {
            position: absolute;
            top: 150px; width: 100%;
            text-align: center;
            font-size: 1.2rem;
            color: #d22;
            text-shadow: 0 0 10px #d22;
            display: none;
            pointer-events: none;
            letter-spacing: 3px;
            animation: pulseAlert 1s infinite;
        }
        @keyframes pulseAlert { 0% { opacity: 0.5; } 50% { opacity: 1; } 100% { opacity: 0.5; } }


        /* Controls */
        #mobile-controls {
            position: absolute;
            bottom: 30px; left: 0; width: 100%; height: 120px;
            pointer-events: none;
            z-index: 30;
            display: flex; justify-content: space-between; align-items: center;
            padding: 0 40px; box-sizing: border-box;
        }
        .control-btn {
            width: 100px; height: 100px;
            border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.1);
            background: rgba(0,0,0,0.5);
            color: rgba(255,255,255,0.4);
            display: flex; justify-content: center; align-items: center;
            font-size: 1rem; letter-spacing: 2px;
            pointer-events: auto;
            backdrop-filter: blur(5px);
            transition: 0.1s;
        }
        #btn-focus.active {
            border-color: #4ff; color: #4ff;
            background: rgba(0,255,255,0.1);
            box-shadow: 0 0 20px rgba(0,255,255,0.2);
        }
        #btn-fire { border-color: rgba(255,50,50,0.3); color: rgba(255,100,100,0.8); }
        #btn-fire:active {
            background: rgba(255,0,0,0.3); color: #fff;
            transform: scale(0.95);
            box-shadow: 0 0 30px rgba(255,0,0,0.5);
        }

        /* Result Stamp */
        .result-stamp {
            font-size: 4rem; font-weight: bold;
            transform: rotate(-15deg);
            border: 8px solid; padding: 10px 40px;
            display: inline-block; margin-bottom: 30px;
            opacity: 0;
            text-transform: uppercase;
            animation: stampIn 0.2s cubic-bezier(0.5, 0, 0.5, 1.5) forwards 0.5s;
        }
        @keyframes stampIn { from { opacity: 0; transform: scale(3) rotate(-15deg); } to { opacity: 1; transform: scale(1) rotate(-15deg); } }
        .stamp-success { color: #d22; border-color: #d22; text-shadow: 0 0 20px rgba(221, 34, 34, 0.5); }
        .stamp-fail { color: #888; border-color: #888; }
        
        .hint-text {
            color: #666; font-size: 0.8rem; margin-top: 10px;
        }
    </style>
</head>
<body>

<canvas id="gameCanvas"></canvas>
<div id="noise-overlay"></div>

<div id="ui-layer">
    <!-- ブリーフィング -->
    <div id="briefing-box" class="message-box">
        <h1>
            <span class="nav-btn" id="prev-level">&lt;</span>
            <span id="briefing-title">CONTRACT #000</span>
            <span class="nav-btn" id="next-level">&gt;</span>
        </h1>
        <div id="highscore-display" class="highscore-info">
            BEST: <span class="highscore-val" id="hs-time">--</span> s / <span class="highscore-val" id="hs-acc">--</span> %
        </div>
        <div id="briefing-content">
            <h2>TARGET</h2>
            <div class="mission-detail typing" id="briefing-target"></div>
            <h2>INTEL</h2>
            <div class="mission-detail typing" id="briefing-intel"></div>
        </div>
        <div class="hint-text">※ 弾は風に流されます。FOCUS (Space/ボタン) でタイミングを合わせてください。</div>
        <div class="btn disabled" id="briefing-btn">ACCEPT</div>
    </div>

    <!-- リザルト -->
    <div id="result-box" class="message-box">
        <div id="result-stamp" class="result-stamp">ELIMINATED</div>
        <div class="mission-detail" id="result-detail"></div>
        <div class="btn" id="result-btn">PROCEED</div>
    </div>
</div>

<!-- HUD -->
<div id="bpm-display" class="hud-info">
    <span>BPM </span><span id="bpm-value">60</span>
</div>
<div id="wind-display" class="hud-info">
    <span>WIND </span><span id="wind-value">0.0 m/s</span>
</div>
<div id="alert-display">STRUCTURAL INTEGRITY COMPROMISED - STRIKE AGAIN</div>

<!-- 操作ボタン -->
<div id="mobile-controls">
    <div id="btn-focus" class="control-btn">FOCUS</div>
    <div id="btn-fire" class="control-btn">FIRE</div>
</div>

<script>
/**
 * THE CONTRACT - PROFESSIONAL SNIPER SIM (PRO EDITION)
 * v3.0 Updates:
 * - Difficulty Rebalance: "Pro Feel" (More stable focus, better auto-comp)
 * - Stage Selection: Play any mission directly
 * - High Score System: Tracks Time & Accuracy using LocalStorage
 */

// ==========================================
// 1. CONFIGURATION
// ==========================================

const GLOBAL = {
    // 物理定数
    BASE_SWAY: 120,        // 手ブレの基本振幅
    SWAY_SPEED: 0.0015,    // 手ブレ速度
    WIND_INFLUENCE: 2.0,   // 風速1m/sあたりの着弾ズレ(px)
    
    // 【調整】プロ仕様の補正（難易度緩和）
    AUTO_COMPENSATION: 0.92, // 自動風補正率 (85% -> 92%: 風読みの負担を軽減)
    HIT_RADIUS: 28,          // 命中判定半径 (22 -> 28: 少し当たりやすく)
    
    // FOCUS補正
    FOCUS_SLOW: 0.1,       // FOCUS時の時間経過速度
    // 【調整】フォーカス時の安定性強化
    FOCUS_STABILIZE: 0.3,  // FOCUS時の振幅抑制率 (0.6 -> 0.3: ピタッと止まる感覚に)
    
    // BPM
    BPM_BASE: 60,
    BPM_MAX: 180,
    BPM_LIMIT: 130,
    BPM_RISE: 30,
    BPM_RECOVER: 15,
    
    CRACK_TOLERANCE: 20,   // 2発目の許容誤差(px) (15 -> 20: 緩和)
};

const LEVELS = [
    {
        id: 1,
        title: "CONTRACT #001: THE WATCHER",
        target: "ターゲット：監視員\nビルの屋上で静止している。",
        intel: "微風。まずは落ち着いて狙え。\nFOCUS中にレティクルが赤くなった瞬間が、必中のタイミングだ。",
        fail: "ターゲット逃走。初歩的なミスだ。",
        type: 'static', bg: 'day',
        windMin: 5, windMax: 15, dist: 1.0 // 風を少し弱く
    },
    {
        id: 2,
        title: "CONTRACT #002: CROWDED LOBBY",
        target: "ターゲット：青いネクタイの男\n空港ロビーにて移動中。",
        intel: "人混みでの狙撃。\n民間人への誤射は許されない。\nオートトラッカーが風を計算し、照準を風上に補正する。",
        fail: "一般人を巻き込んだ可能性がある。即時撤退。",
        type: 'moving', bg: 'sunset',
        windMin: 20, windMax: 40, dist: 0.8, civilians: 5 // 民間人を1人減
    },
    {
        id: 3,
        title: "CONTRACT #003: GALE FORCE",
        target: "ターゲット：武器商人\nペントハウスの防弾ガラス越し。",
        intel: "強風警報。\n弾道が大きく逸れるが、スコープの自動補正を信じろ。\n補正しきれない「残りわずかなズレ」を手ブレで合わせろ。",
        fail: "ガラスに弾かれた。チャンスは失われた。",
        type: 'glass', bg: 'night',
        windMin: 60, windMax: 100, dist: 0.7
    },
    {
        id: 4,
        title: "CONTRACT #004: RICOCHET",
        target: "ターゲット：敵対スナイパー\n壁の死角に潜んでいる。",
        intel: "直射不可能。\n左側の金属プレートへの「跳弾」を利用せよ。\nシステムは自動的に反射板の中心をロックオンする。",
        fail: "角度計算を誤った。反撃を受けるぞ。",
        type: 'ricochet', bg: 'day',
        windMin: 15, windMax: 45, dist: 0.6
    },
    {
        id: 5,
        title: "CONTRACT #005: ZERO POINT",
        target: "ターゲット：コードネーム「ゼロ」\n洋上プラットフォーム。",
        intel: "暴風雨。\n視界不良、極限の環境。\n心拍を制御し、嵐の隙間を縫って撃て。",
        fail: "自然の猛威に敗北した。",
        type: 'storm', bg: 'storm',
        windMin: 120, windMax: 200, dist: 0.5
    },
    {
        id: 6,
        title: "CONTRACT #006: SYNCHRONICITY",
        target: "ターゲット：密輸業者\n線路の向こう側で取引中。",
        intel: "高速貨物列車が視界を遮る。\nコンテナの「連結部の隙間」を縫って撃て。\nタイミングが全てだ。",
        fail: "貨物コンテナに着弾。警戒された。",
        type: 'gap_shot', bg: 'sunset',
        windMin: 30, windMax: 60, dist: 0.7, trainSpeed: 350 // 少し遅く
    },
    {
        id: 7,
        title: "CONTRACT #007: HAMMER PAIR",
        target: "ターゲット：要人警護対象\n強化防弾ガラスの奥。",
        intel: "特殊任務。ガラスは一発では割れない。\n一点に衝撃を集中させろ。\n「同じ着弾点」に二発目を撃ち込み、貫通させるのだ。",
        fail: "ガラスを貫通できず。警報が鳴った。",
        type: 'armor_piercing', bg: 'night',
        windMin: 10, windMax: 30, dist: 0.9
    }
];

// ==========================================
// 2. STATE MANAGEMENT & STORAGE
// ==========================================

const STATE = { BRIEFING: 0, PLAYING: 1, IMPACT: 2, RESULT: 3, ALL_CLEAR: 4 };

let currentState = STATE.BRIEFING;
let currentLevel = 0;
let levelData = null;
let isRetry = false; 

// Score Handling
let startTime = 0;
const STORAGE_KEY = 'sniper_contract_scores';

function getScores() {
    try {
        const d = localStorage.getItem(STORAGE_KEY);
        return d ? JSON.parse(d) : {};
    } catch(e) { return {}; }
}

function saveScore(levelId, time, accuracy) {
    const scores = getScores();
    const current = scores[levelId] || { time: 999, acc: 0 };
    
    // スコア更新条件: 精度優先、同精度ならタイム
    if (accuracy > current.acc || (accuracy === current.acc && time < current.time)) {
        scores[levelId] = { time: parseFloat(time.toFixed(2)), acc: parseFloat(accuracy.toFixed(1)) };
        localStorage.setItem(STORAGE_KEY, JSON.stringify(scores));
        return true; // New Record
    }
    return false;
}

// World Objects
let targets = [];
let obstacles = [];
let reflector = null;
let tracers = []; 
let existingCracks = []; 

// Physics & Player
let wind = { x: 0, y: 0, power: 0 }; 
let camera = { x: 0, y: 0 };         
let sway = { x: 0, y: 0, time: 0 };  
let aimLock = { active: false, x: 0, y: 0 }; 

let bpm = GLOBAL.BPM_BASE;
let isFocusing = false;
let isPenalty = false;
let isLockedOn = false; 
let lightning = 0;
let hitResult = null;
let impactTimer = 0;

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const alertDisplay = document.getElementById('alert-display');

// ==========================================
// 3. INITIALIZATION & EVENTS
// ==========================================

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

const ui = {
    briefing: document.getElementById('briefing-box'),
    result: document.getElementById('result-box'),
    bpmVal: document.getElementById('bpm-value'),
    bpmDisplay: document.getElementById('bpm-display'),
    windVal: document.getElementById('wind-value'),
    briefingBtn: document.getElementById('briefing-btn'),
    
    hsTime: document.getElementById('hs-time'),
    hsAcc: document.getElementById('hs-acc'),
    
    // Typing Effect
    typingTimer: null,
    isTyping: false,
    textQueue: [],
    
    showBriefing: (idx) => {
        // Range check
        if (idx < 0) idx = LEVELS.length - 1;
        if (idx >= LEVELS.length) idx = 0;
        currentLevel = idx; // Update current level pointer

        const data = LEVELS[idx];
        document.getElementById('briefing-title').textContent = data.title;
        
        // Show Highscore
        const scores = getScores();
        const sc = scores[data.id];
        if (sc) {
            ui.hsTime.textContent = sc.time;
            ui.hsAcc.textContent = sc.acc;
        } else {
            ui.hsTime.textContent = "--";
            ui.hsAcc.textContent = "--";
        }
        
        ui.textQueue = [
            { el: document.getElementById('briefing-target'), text: data.target },
            { el: document.getElementById('briefing-intel'), text: data.intel }
        ];
        
        ui.textQueue.forEach(q => { q.el.textContent = ""; q.el.classList.remove('done'); });
        ui.briefingBtn.classList.add('disabled');
        ui.hideAll();
        ui.briefing.classList.add('active');
        currentState = STATE.BRIEFING;
        
        if (isRetry) {
            ui.skipTyping();
        } else {
            ui.processTypingQueue();
        }
    },
    
    processTypingQueue: () => {
        if (ui.textQueue.length === 0) {
            ui.finishTyping();
            return;
        }
        const item = ui.textQueue.shift();
        ui.typeText(item.el, item.text, () => {
            item.el.classList.add('done');
            setTimeout(ui.processTypingQueue, 300);
        });
    },

    typeText: (el, text, callback) => {
        ui.isTyping = true;
        let i = 0;
        clearInterval(ui.typingTimer);
        ui.typingTimer = setInterval(() => {
            el.textContent += text.charAt(i);
            if (/\S/.test(text.charAt(i))) playSound('type');
            i++;
            if (i >= text.length) {
                clearInterval(ui.typingTimer);
                if (callback) callback();
            }
        }, 20);
    },

    skipTyping: () => {
        clearInterval(ui.typingTimer);
        const data = LEVELS[currentLevel];
        const targetEl = document.getElementById('briefing-target');
        const intelEl = document.getElementById('briefing-intel');
        targetEl.textContent = data.target; targetEl.classList.add('done');
        intelEl.textContent = data.intel; intelEl.classList.add('done');
        ui.textQueue = [];
        ui.finishTyping();
    },

    finishTyping: () => {
        ui.isTyping = false;
        ui.briefingBtn.classList.remove('disabled');
    },

    showResult: (success, reason, stats) => {
        const stamp = document.getElementById('result-stamp');
        const detail = document.getElementById('result-detail');
        const btn = document.getElementById('result-btn');
        
        if (success) {
            stamp.textContent = "ELIMINATED";
            stamp.className = "result-stamp stamp-success";
            
            // New Record Check
            const isNewRecord = saveScore(levelData.id, stats.time, stats.acc);
            
            let msg = `TIME: ${stats.time.toFixed(2)}s\nACCURACY: ${stats.acc.toFixed(1)}%\n`;
            if (isNewRecord) msg += "\n>> NEW RECORD <<";
            else msg += "\nターゲット沈黙確認。";
            
            detail.textContent = msg;
            btn.textContent = "NEXT CONTRACT";
            isRetry = false;
        } else {
            stamp.textContent = "FAILED";
            stamp.className = "result-stamp stamp-fail";
            detail.textContent = reason || "任務失敗。";
            btn.textContent = "RETRY";
            isRetry = true;
        }
        ui.hideAll();
        ui.result.classList.add('active');
        currentState = STATE.RESULT;
    },
    
    hideAll: () => {
        ui.briefing.classList.remove('active');
        ui.result.classList.remove('active');
        alertDisplay.style.display = 'none';
        clearInterval(ui.typingTimer);
        ui.isTyping = false;
    },
    updateHUD: () => {
        ui.bpmVal.textContent = Math.floor(bpm);
        if (bpm > GLOBAL.BPM_LIMIT) ui.bpmDisplay.classList.add('bpm-danger');
        else ui.bpmDisplay.classList.remove('bpm-danger');
        
        ui.windVal.textContent = (wind.power).toFixed(1) + " m/s";
    }
};

// --- Input Handling ---

const btnFocus = document.getElementById('btn-focus');
const btnFire = document.getElementById('btn-fire');

// Focus
const startFocus = (e) => {
    e.preventDefault();
    if (currentState === STATE.PLAYING && !isPenalty) {
        isFocusing = true;
        btnFocus.classList.add('active');
        toggleAmbience(false); 
    }
};
const endFocus = (e) => {
    e.preventDefault();
    isFocusing = false;
    btnFocus.classList.remove('active');
    toggleAmbience(true);
};

// Fire
const handleFire = (e) => {
    e.preventDefault();
    if (currentState === STATE.PLAYING) {
        btnFire.style.transform = "scale(0.9)";
        setTimeout(() => btnFire.style.transform = "scale(1)", 100);
        fireShot();
    }
};

// Keybinds
document.addEventListener('keydown', e => {
    if (e.code === 'Space' && !e.repeat) startFocus(e);
    // Stage Select Shortcuts
    if (currentState === STATE.BRIEFING) {
        if (e.code === 'ArrowLeft') ui.showBriefing(currentLevel - 1);
        if (e.code === 'ArrowRight') ui.showBriefing(currentLevel + 1);
    }
});
document.addEventListener('keyup', e => {
    if (e.code === 'Space') endFocus(e);
});
document.addEventListener('mousedown', e => {
    if (e.target.id === 'gameCanvas' && currentState === STATE.PLAYING) fireShot();
});

btnFocus.addEventListener('touchstart', startFocus);
btnFocus.addEventListener('touchend', endFocus);
btnFocus.addEventListener('mousedown', startFocus);
btnFocus.addEventListener('mouseup', endFocus);

btnFire.addEventListener('touchstart', handleFire);

// UI Clicks (Briefing & Navigation)
document.getElementById('briefing-btn').addEventListener('click', (e) => {
    e.stopPropagation();
    if (!ui.briefingBtn.classList.contains('disabled')) {
        initAudio(); initLevel(currentLevel);
    }
});
document.getElementById('briefing-box').addEventListener('click', (e) => {
    // Only skip typing if clicking the box body, not buttons
    if (e.target.classList.contains('nav-btn')) return;
    if (e.target.id !== 'briefing-btn') {
        initAudio();
        if (ui.isTyping) ui.skipTyping();
    }
});
// Stage Selection Buttons
document.getElementById('prev-level').addEventListener('click', (e) => {
    e.stopPropagation(); ui.showBriefing(currentLevel - 1);
});
document.getElementById('next-level').addEventListener('click', (e) => {
    e.stopPropagation(); ui.showBriefing(currentLevel + 1);
});

document.getElementById('result-btn').addEventListener('click', () => {
    if (hitResult && hitResult.success) { currentLevel++; }
    ui.showBriefing(currentLevel);
});

// ==========================================
// 4. GAME LOGIC
// ==========================================

function initLevel(idx) {
    if (idx >= LEVELS.length) idx = 0; // Wrap around safely
    currentLevel = idx;
    levelData = LEVELS[idx];
    
    ui.hideAll();
    currentState = STATE.PLAYING;
    hitResult = null;
    startTime = Date.now(); // Start timer
    
    bpm = GLOBAL.BPM_BASE;
    isFocusing = false;
    isPenalty = false;
    isLockedOn = false;
    sway = { x: 0, y: 0, time: 0 };
    camera = { x: 0, y: 0 };
    lightning = 0;
    tracers = [];
    existingCracks = [];
    
    // Wind Generation
    const angle = Math.random() * Math.PI * 2;
    const power = levelData.windMin + Math.random() * (levelData.windMax - levelData.windMin);
    wind = { 
        x: Math.cos(angle) * power, 
        y: Math.sin(angle) * power, 
        power: power 
    };

    // Initialize Objects
    targets = []; obstacles = []; reflector = null;
    
    if (levelData.type === 'static' || levelData.type === 'gap_shot' || levelData.type === 'armor_piercing' || levelData.type === 'glass') {
        targets.push(createChar(0, 0, true));
    }
    
    if (levelData.type === 'moving') {
        targets.push(createChar(0, 0, true)); 
        for(let i=0; i<levelData.civilians; i++) {
            let cx, cy, dist;
            let attempts = 0;
            do {
                cx = (Math.random()-0.5)*800;
                cy = (Math.random()-0.5)*400;
                dist = Math.sqrt(cx*cx + cy*cy);
                attempts++;
            } while (dist < 80 && attempts < 20);
            targets.push(createChar(cx, cy, false));
        }
    }
    else if (levelData.type === 'glass') {
        obstacles.push({ x: -200, y: -100, w: 150, h: 200, type: 'glass', speed: 1.2, baseX: -200 });
        obstacles.push({ x: 50, y: -100, w: 150, h: 200, type: 'glass', speed: 1.2, baseX: 50 });
    }
    else if (levelData.type === 'ricochet') {
        targets = []; 
        targets.push(createChar(400, 0, true));
        obstacles.push({ x: 150, y: -200, w: 200, h: 400, type: 'wall' });
        reflector = { x: -250, y: -80, w: 50, h: 160 };
    }
    else if (levelData.type === 'storm') targets.push(createChar(0, 0, true));
    else if (levelData.type === 'gap_shot') {
        const carW = 300;
        const gap = 120;
        const total = 4;
        const offset = -600;
        for(let i=0; i<total; i++) {
            obstacles.push({
                x: offset + i * (carW + gap), y: -120, w: carW, h: 240, 
                type: 'train', speed: levelData.trainSpeed, id: i 
            });
        }
    }
    else if (levelData.type === 'armor_piercing') {
        obstacles.push({ x: -100, y: -150, w: 200, h: 300, type: 'reinforced_glass' });
    }

    playAmbience(levelData.type === 'storm');
    requestAnimationFrame(gameLoop);
}

function createChar(x, y, isTarget) {
    return {
        x: x, y: y, baseX: x, baseY: y,
        isTarget: isTarget,
        hasTie: isTarget && levelData.type === 'moving',
        phase: Math.random() * Math.PI * 2
    };
}

let lastTime = 0;
let lastBeat = 0;
let pulseVal = 0;

function gameLoop(time) {
    const dt = time - lastTime;
    lastTime = time;
    
    update(dt, time);
    draw(time);
    
    // Heartbeat Logic
    if (currentState === STATE.PLAYING) {
        if (time - lastBeat > (60000 / bpm)) {
            playSound('heartbeat', isFocusing ? 1.0 : 0.0);
            lastBeat = time;
            if (isFocusing) pulseVal = 0.05; 
        }
    }
    pulseVal *= 0.9;

    if (currentState !== STATE.RESULT && currentState !== STATE.ALL_CLEAR) requestAnimationFrame(gameLoop);
}

function update(dt, time) {
    if (currentState === STATE.IMPACT) {
        impactTimer -= dt;
        if (impactTimer <= 0) {
            currentState = STATE.RESULT;
            ui.showResult(hitResult.success, hitResult.reason, hitResult.stats);
        }
    }
    
    tracers.forEach(t => t.alpha -= dt * 0.0005);
    tracers = tracers.filter(t => t.alpha > 0);

    if (currentState !== STATE.PLAYING) return;

    // --- 1. BPM Logic ---
    if (isFocusing) {
        bpm += GLOBAL.BPM_RISE * (dt/1000);
        if (bpm > GLOBAL.BPM_LIMIT) {
            isFocusing = false; isPenalty = true;
            btnFocus.classList.remove('active');
            toggleAmbience(true); playSound('gasp');
            setTimeout(() => isPenalty = false, 4000);
        }
    } else {
        bpm = Math.max(GLOBAL.BPM_BASE, bpm - GLOBAL.BPM_RECOVER * (dt/1000));
    }
    ui.updateHUD();

    // --- 2. Camera & Sway Logic ---
    let aimX = 0, aimY = 0;
    if (levelData.type === 'ricochet' && reflector) {
        aimX = reflector.x + reflector.w / 2;
        aimY = reflector.y + reflector.h / 2;
    } else {
        let t = targets.find(t => t.isTarget);
        if (t) { aimX = t.x; aimY = t.y; }
    }

    const fullDriftX = wind.x * GLOBAL.WIND_INFLUENCE;
    const fullDriftY = wind.y * GLOBAL.WIND_INFLUENCE;
    const compX = -fullDriftX * GLOBAL.AUTO_COMPENSATION;
    const compY = -fullDriftY * GLOBAL.AUTO_COMPENSATION;
    const remainingDriftX = fullDriftX * (1.0 - GLOBAL.AUTO_COMPENSATION);
    const remainingDriftY = fullDriftY * (1.0 - GLOBAL.AUTO_COMPENSATION);
    const remainingDist = Math.sqrt(remainingDriftX**2 + remainingDriftY**2);

    let swaySpeed = GLOBAL.SWAY_SPEED;
    let swayAmp = GLOBAL.BASE_SWAY;
    
    if (isFocusing) {
        swaySpeed *= GLOBAL.FOCUS_SLOW;
        const minAmp = remainingDist + 20; 
        swayAmp = Math.max(minAmp, swayAmp * GLOBAL.FOCUS_STABILIZE);
    }
    if (isPenalty) { swaySpeed *= 2.0; swayAmp *= 3.0; }
    
    const stress = Math.max(0, (bpm - GLOBAL.BPM_BASE) / 50);
    swaySpeed *= (1 + stress);
    swayAmp *= (1 + stress * 0.5);

    sway.time += dt * swaySpeed;
    sway.x = Math.sin(sway.time) * swayAmp;
    sway.y = Math.sin(sway.time * 2.1) * (swayAmp * 0.5);

    camera.x = aimX + compX + sway.x;
    camera.y = aimY + compY + sway.y;

    // --- 3. Object Updates ---
    targets.forEach(t => {
        if (levelData.type === 'moving') {
            t.x = t.baseX + Math.sin(time * 0.001 + t.phase) * 120;
        }
    });
    obstacles.forEach(o => {
        if (o.type === 'glass') {
            o.x = o.baseX + Math.sin(time * 0.001 * o.speed) * 80;
        } else if (o.type === 'train') {
            o.x += (dt/1000) * o.speed;
            if (o.x > 1200) o.x -= 1680;
        }
    });

    if (levelData.type === 'storm') {
        if (lightning > 0) lightning -= 0.05;
        if (Math.random() < 0.005) { lightning = 1.0; playSound('thunder'); }
    }

    // --- 4. Hit Forecast ---
    isLockedOn = checkHitForecast();
}

function checkHitForecast() {
    if (!isFocusing) return false;
    const driftX = wind.x * GLOBAL.WIND_INFLUENCE;
    const driftY = wind.y * GLOBAL.WIND_INFLUENCE;
    const impactX = camera.x + driftX;
    const impactY = camera.y + driftY;

    // Obstacles Check
    for (let o of obstacles) {
        if (o.type === 'reinforced_glass') {
            if (existingCracks.length > 0) {
                 const c = existingCracks[0];
                 const dist = Math.sqrt((impactX - c.x)**2 + (impactY - c.y)**2);
                 if (dist < GLOBAL.CRACK_TOLERANCE) continue; 
            }
        }
        if (impactX > o.x && impactX < o.x + o.w && impactY > o.y && impactY < o.y + o.h) return false;
    }

    if (levelData.type === 'ricochet' && reflector) {
         if (impactX > reflector.x && impactX < reflector.x + reflector.w && 
            impactY > reflector.y && impactY < reflector.y + reflector.h) return true;
         return false;
    }

    const r = GLOBAL.HIT_RADIUS * levelData.dist;
    for (let t of targets) {
        if (t.isTarget) {
            let dist = Math.sqrt((impactX - t.x)**2 + (impactY - t.y)**2);
            if (dist < r) return true;
        }
    }
    return false;
}

function fireShot() {
    playSound('gunshot');
    setTimeout(() => playSound('shell'), 800); 

    const driftX = wind.x * GLOBAL.WIND_INFLUENCE;
    const driftY = wind.y * GLOBAL.WIND_INFLUENCE;
    const impactX = camera.x + driftX;
    const impactY = camera.y + driftY;

    tracers.push({ sx: camera.x, sy: camera.y, ex: impactX, ey: impactY, alpha: 1.0 });

    let success = false, reason = "", hitSomething = false;
    let hitObj = null; // To track what we hit for accuracy calc

    // 1. Obstacles
    for (let o of obstacles) {
        if (impactX > o.x && impactX < o.x + o.w && impactY > o.y && impactY < o.y + o.h) {
            hitSomething = true;
            if (o.type === 'glass') { 
                reason = "防弾ガラスに着弾。"; playSound('ricochet'); 
            } else if (o.type === 'train') {
                reason = "貨物に命中。タイミングが遅い。"; playSound('ricochet');
            } else if (o.type === 'wall') {
                reason = "壁に着弾。"; playSound('ricochet');
            } else if (o.type === 'reinforced_glass') {
                // ARMOR PIERCING LOGIC
                let pierced = false;
                if (existingCracks.length > 0) {
                    const c = existingCracks[0];
                    const dist = Math.sqrt((impactX - c.x)**2 + (impactY - c.y)**2);
                    if (dist < GLOBAL.CRACK_TOLERANCE) {
                        pierced = true;
                        hitSomething = false; 
                    } else {
                        reason = "ヒビからズレている。貫通失敗。";
                        playSound('ricochet');
                    }
                }
                if (!pierced) {
                    if (existingCracks.length === 0) {
                        existingCracks.push({ x: impactX, y: impactY });
                        playSound('crack');
                        alertDisplay.style.display = 'block'; 
                        return; // Continue
                    } else {
                        hitSomething = true; 
                    }
                }
            }
            if (hitSomething) break;
        }
    }

    // 2. Reflector
    if (!hitSomething && reflector) {
        if (impactX > reflector.x && impactX < reflector.x + reflector.w && 
            impactY > reflector.y && impactY < reflector.y + reflector.h) {
            
            hitSomething = true; playSound('ricochet');
            let t = targets.find(t => t.isTarget);
            // Ricochet success - we assume perfect aim from here for simplicity or calc dist
            hitResult = { success: true, x: impactX, y: impactY, ricochet: {x: t.x, y: t.y} };
            success = true;
            hitObj = { x: reflector.x + reflector.w/2, y: reflector.y + reflector.h/2 }; // Center of reflector
        }
    }

    // 3. Targets
    if (!hitSomething) {
        const r = GLOBAL.HIT_RADIUS * levelData.dist;
        for (let t of targets) {
            let dist = Math.sqrt((impactX - t.x)**2 + (impactY - t.y)**2);
            if (dist < r) {
                hitSomething = true;
                if (t.isTarget) {
                    success = true;
                    hitObj = t;
                }
                else { success = false; reason = "一般市民を殺害。任務失敗。"; }
                break;
            }
        }
    }

    if (!hitSomething && !success) reason = "ターゲットを外した。";
    
    // Stats Calculation
    let stats = { time: 0, acc: 0 };
    if (success) {
        const timeElapsed = (Date.now() - startTime) / 1000;
        let accuracy = 0;
        
        // Calculate accuracy based on distance to center of mass
        if (hitObj) {
            // Reflector center or Target center
            let targetX = hitObj.x;
            let targetY = hitObj.y;
            // For reflector, we used center. For Target, it's t.x/t.y
            
            let dist = Math.sqrt((impactX - targetX)**2 + (impactY - targetY)**2);
            // Normalize: 0 dist = 100%, HIT_RADIUS = 50% (just hit edge)
            // But let's map: 0px -> 100%, HIT_RADIUS -> 70%
            let maxR = GLOBAL.HIT_RADIUS * (levelData.dist || 1);
            let p = 1.0 - (dist / (maxR * 2)); // simple linear
            if (p < 0) p = 0;
            accuracy = p * 100;
        }
        
        stats = { time: timeElapsed, acc: accuracy };
    }

    if (!hitResult) hitResult = { success: success, reason: reason, x: impactX, y: impactY, stats: stats };

    // Impact
    currentState = STATE.IMPACT;
    impactTimer = success ? 2500 : 1500;
    playSound(success ? 'impact' : 'miss');
}

// ==========================================
// 5. RENDERING
// ==========================================

function draw(time) {
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Weather Brightness
    let brightness = 1.0;
    if (levelData.bg === 'storm' || levelData.bg === 'night') brightness = 0.4;
    else if (levelData.bg === 'sunset') brightness = 0.6;
    if (lightning > 0) brightness = 1.5;

    // Kill Effect
    if (currentState === STATE.IMPACT && hitResult.success) {
        ctx.filter = 'grayscale(100%) contrast(150%)';
        brightness *= 1.5;
    } else {
        ctx.filter = 'none';
    }

    ctx.save();

    // Camera
    let zoom = isFocusing ? 3.5 : 1.2; 
    zoom += pulseVal; 
    if (isPenalty) zoom += Math.sin(time*0.1)*0.1;
    
    const cx = canvas.width/2;
    const cy = canvas.height/2;

    ctx.translate(cx, cy);
    ctx.scale(zoom, zoom);
    ctx.translate(-camera.x, -camera.y);

    drawSky(brightness);
    drawBackground(brightness);
    drawObjects(time, brightness);
    drawCracks(); 
    drawTracers();
    
    if (hitResult) drawHitMarker();

    ctx.restore();

    // Overlays
    ctx.filter = 'none';
    if (levelData.bg === 'storm') drawRain(time);
    
    drawScope(cx, cy);
}

function drawSky(b) {
    const w=5000, h=5000;
    const g = ctx.createLinearGradient(0, -2000, 0, 2000);
    if (levelData.bg === 'day') { g.addColorStop(0,`rgba(135,206,235,${b})`); g.addColorStop(1,`rgba(200,230,255,${b})`); }
    else if (levelData.bg === 'sunset') { g.addColorStop(0,`rgba(20,10,30,${b})`); g.addColorStop(1,`rgba(150,50,30,${b})`); }
    else { g.addColorStop(0,`rgba(5,5,10,${b})`); g.addColorStop(1,`rgba(20,20,30,${b})`); }
    ctx.fillStyle = g; ctx.fillRect(-w/2, -h/2, w, h);
    
    // Moving Clouds
    ctx.fillStyle = `rgba(255,255,255,${b*0.1})`;
    for(let i=0; i<8; i++) {
        let x = ((Date.now()*0.01*wind.power + i*600)%4000) - 2000;
        ctx.beginPath(); ctx.arc(x, -500+i*50, 200+i*30, 0, Math.PI*2); ctx.fill();
    }
}

function drawBackground(b) {
    drawBuilding(-400, -500, 800, 1200, b, 60);
    drawBuilding(-900, -300, 400, 1000, b*0.8, 40);
    drawBuilding(500, -400, 500, 1100, b*0.8, 50);
}

function drawBuilding(x, y, w, h, b, win) {
    ctx.fillStyle = `rgba(10,12,15,${b})`; ctx.fillRect(x,y,w,h);
    const cols = (w-20)/win|0, rows = (h-20)/(win*1.5)|0;
    ctx.fillStyle = `rgba(255,240,150,${b*0.5})`;
    for(let i=0;i<cols;i++) for(let j=0;j<rows;j++) {
        if(Math.sin(i*9+j*7+x)>0.3) ctx.fillRect(x+10+i*win, y+20+j*win*1.5, win-10, win*1.2);
    }
}

function drawObjects(time, b) {
    targets.forEach(t => {
        ctx.save(); ctx.translate(t.x, t.y); ctx.scale(levelData.dist, levelData.dist);
        
        if(t.isTarget && levelData.type !== 'moving') {
            ctx.fillStyle = `rgba(255,200,100,${b*0.6})`;
            ctx.shadowBlur=30; ctx.shadowColor='orange';
            ctx.fillRect(-25,-40,50,100); ctx.shadowBlur=0;
        }
        
        ctx.fillStyle = `rgba(5,5,5,${b})`;
        ctx.beginPath(); ctx.arc(0,0,10,0,Math.PI*2); ctx.fill();
        ctx.fillRect(-12,12,24,40);
        
        if(t.hasTie) {
            ctx.fillStyle = `rgba(50,100,255,${b*1.5})`;
            ctx.beginPath(); ctx.moveTo(0,14); ctx.lineTo(4,35); ctx.lineTo(0,40); ctx.lineTo(-4,35); ctx.fill();
        }
        ctx.restore();
    });

    obstacles.forEach(o => {
        if(o.type==='glass' || o.type==='reinforced_glass') {
            const g=ctx.createLinearGradient(o.x,o.y,o.x+o.w,o.y+o.h);
            const op = o.type === 'reinforced_glass' ? 0.3 : 0.2;
            g.addColorStop(0,'rgba(200,255,255,0.05)'); g.addColorStop(0.5,`rgba(255,255,255,${op})`); g.addColorStop(1,'rgba(200,255,255,0.05)');
            ctx.fillStyle=g; ctx.fillRect(o.x,o.y,o.w,o.h);
            ctx.strokeStyle= o.type==='reinforced_glass' ? 'rgba(200,255,200,0.5)' : 'rgba(255,255,255,0.3)';
            ctx.lineWidth = o.type==='reinforced_glass' ? 3 : 1;
            ctx.strokeRect(o.x,o.y,o.w,o.h);
        } else if (o.type === 'train') {
            // Train drawing
            ctx.fillStyle = '#221510'; // Dark rust color
            ctx.fillRect(o.x, o.y, o.w, o.h);
            // Details
            ctx.fillStyle = '#332015';
            ctx.fillRect(o.x+10, o.y+10, o.w-20, o.h-20);
            // Container ribs
            ctx.fillStyle = '#150a05';
            for(let i=0; i<o.w; i+=30) ctx.fillRect(o.x+i, o.y, 10, o.h);
            // Label
            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            ctx.font = '20px Arial';
            ctx.fillText("CARGO-"+o.id, o.x+20, o.y+50);
        } else {
            ctx.fillStyle=`rgba(30,30,35,${b})`; ctx.fillRect(o.x,o.y,o.w,o.h);
        }
    });

    if(reflector) {
        ctx.fillStyle='#888'; ctx.fillRect(reflector.x,reflector.y,reflector.w,reflector.h);
        ctx.fillStyle='rgba(255,255,255,0.9)'; ctx.fillRect(reflector.x+2,reflector.y,5,reflector.h);
    }
}

function drawCracks() {
    existingCracks.forEach(c => {
        ctx.save();
        ctx.translate(c.x, c.y);
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        // Spiderweb pattern
        for (let i = 0; i < 8; i++) {
            const ang = i * (Math.PI/4) + (c.x % 1); // Randomize angle slightly
            ctx.moveTo(0,0);
            ctx.lineTo(Math.cos(ang) * 40, Math.sin(ang) * 40);
        }
        ctx.stroke();
        // Concentric
        ctx.beginPath(); ctx.arc(0,0,15,0,Math.PI*2); ctx.stroke();
        ctx.beginPath(); ctx.arc(0,0,30,0,Math.PI*2); 
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)'; ctx.stroke();
        ctx.restore();
    });
}

function drawTracers() {
    ctx.lineWidth = 1;
    tracers.forEach(t => {
        ctx.strokeStyle = `rgba(255, 200, 100, ${t.alpha})`;
        ctx.beginPath();
        ctx.moveTo(t.sx, t.sy);
        ctx.lineTo(t.ex, t.ey);
        ctx.stroke();
    });
}

function drawHitMarker() {
    const {x, y, success, ricochet} = hitResult;
    ctx.fillStyle = success ? '#d22' : '#fff';
    ctx.beginPath(); ctx.arc(x, y, 4, 0, Math.PI*2); ctx.fill();
    
    if(ricochet) {
        ctx.strokeStyle = '#fd0'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(ricochet.x, ricochet.y); ctx.stroke();
    }
}

function drawRain(time) {
    const ra = Math.atan2(wind.y, wind.x+50);
    const rdx = Math.cos(ra)*20, rdy = Math.sin(ra)*40;
    ctx.strokeStyle = 'rgba(150,170,200,0.3)'; ctx.lineWidth = 1;
    ctx.beginPath();
    const w = canvas.width, h = canvas.height;
    for(let i=0; i<150; i++) {
        let x = (i*97 + time*4 + wind.x*time*0.02) % w;
        let y = (i*67 + time*6) % h;
        if(x<0) x+=w;
        ctx.moveTo(x,y); ctx.lineTo(x-rdx, y+rdy);
    }
    ctx.stroke();
}

function drawScope(cx, cy) {
    const r = Math.min(canvas.width, canvas.height) * 0.45;
    
    // Mask
    ctx.fillStyle = '#000';
    ctx.beginPath(); ctx.rect(0,0,canvas.width,canvas.height); ctx.arc(cx,cy,r,0,Math.PI*2,true); ctx.fill();
    
    // Lens
    const g = ctx.createRadialGradient(cx,cy,r*0.6,cx,cy,r);
    g.addColorStop(0,'transparent'); g.addColorStop(0.9,'rgba(0,0,0,0.5)'); g.addColorStop(1,'#000');
    ctx.fillStyle = g; ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fill();
    
    // Reticle
    ctx.strokeStyle = isLockedOn ? '#f22' : '#000'; 
    ctx.lineWidth = 1.5;
    if (isLockedOn) {
         ctx.shadowBlur = 10; ctx.shadowColor = '#f00';
    } else {
         ctx.shadowBlur = 0;
    }

    ctx.beginPath(); ctx.moveTo(cx-r,cy); ctx.lineTo(cx+r,cy); ctx.moveTo(cx,cy-r); ctx.lineTo(cx,cy+r); ctx.stroke();
    
    ctx.fillStyle = isLockedOn ? '#f22' : '#000';
    const dotGap = r / 6;
    for(let i=1; i<=4; i++) {
        // H
        ctx.beginPath(); ctx.arc(cx+i*dotGap,cy,2,0,Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(cx-i*dotGap,cy,2,0,Math.PI*2); ctx.fill();
        // V
        ctx.beginPath(); ctx.arc(cx,cy+i*dotGap,2,0,Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(cx,cy-i*dotGap,2,0,Math.PI*2); ctx.fill();
    }
    ctx.shadowBlur = 0; // reset

    // Wind Indicator
    const wx = cx + r*0.65, wy = cy + r*0.65;
    ctx.translate(wx, wy);
    
    // Compass
    ctx.strokeStyle = '#4f4'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(0,0,25,0,Math.PI*2); ctx.stroke();
    ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fill();
    
    // Arrow
    const windAngle = Math.atan2(wind.y, wind.x);
    ctx.rotate(windAngle);
    ctx.beginPath(); ctx.moveTo(-15,0); ctx.lineTo(15,0); ctx.lineTo(10,-5); ctx.moveTo(15,0); ctx.lineTo(10,5); ctx.stroke();
    ctx.rotate(-windAngle); 
    
    ctx.fillStyle = '#4f4'; ctx.font = '10px Courier New'; ctx.textAlign = 'center';
    ctx.fillText("WIND", 0, -35);
    
    ctx.translate(-wx, -wy);
}

// ==========================================
// 6. AUDIO
// ==========================================
let ac = null, amb = null, ambGain = null;

function initAudio() { if(!ac) ac = new (window.AudioContext||window.webkitAudioContext)(); if(ac.state==='suspended') ac.resume(); }

function playSound(type, vol=1.0) {
    if(!ac) return;
    const t = ac.currentTime;
    const osc = ac.createOscillator();
    const g = ac.createGain();
    
    if(type==='type') { 
        osc.type = 'square'; osc.frequency.value = 800+Math.random()*400;
        g.gain.setValueAtTime(0.05, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.05);
        osc.connect(g); g.connect(ac.destination); osc.start(t); osc.stop(t+0.05);
    }
    else if(type==='heartbeat') { 
        osc.frequency.setValueAtTime(60, t); osc.frequency.exponentialRampToValueAtTime(30, t+0.1);
        g.gain.setValueAtTime(0, t); g.gain.linearRampToValueAtTime(vol*1.5, t+0.05); g.gain.exponentialRampToValueAtTime(0.001, t+0.4);
        const f = ac.createBiquadFilter(); f.type='lowpass'; f.frequency.value=120;
        osc.connect(f); f.connect(g); g.connect(ac.destination);
        osc.start(t); osc.stop(t+0.5);
        
        setTimeout(()=>{
            const o2=ac.createOscillator(); const g2=ac.createGain(); const f2=ac.createBiquadFilter(); f2.type='lowpass'; f2.frequency.value=120;
            o2.frequency.setValueAtTime(50, ac.currentTime); o2.frequency.exponentialRampToValueAtTime(30, ac.currentTime+0.1);
            g2.gain.setValueAtTime(0, ac.currentTime); g2.gain.linearRampToValueAtTime(vol*1.0, ac.currentTime+0.05); g2.gain.exponentialRampToValueAtTime(0.001, ac.currentTime+0.4);
            o2.connect(f2); f2.connect(g2); g2.connect(ac.destination); o2.start(ac.currentTime); o2.stop(ac.currentTime+0.5);
        }, 200);
    }
    else if(type==='gunshot') {
        const buf = ac.createBuffer(1, ac.sampleRate, ac.sampleRate);
        const d = buf.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=Math.random()*2-1;
        const src = ac.createBufferSource(); src.buffer = buf;
        const f = ac.createBiquadFilter(); f.type='lowpass'; f.frequency.setValueAtTime(3000,t); f.frequency.exponentialRampToValueAtTime(100,t+0.5);
        g.gain.setValueAtTime(1,t); g.gain.exponentialRampToValueAtTime(0.01,t+0.5);
        src.connect(f); f.connect(g); g.connect(ac.destination); src.start(t);
    }
    else if(type==='shell') { 
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(1200, t); osc.frequency.exponentialRampToValueAtTime(600, t+0.1);
        g.gain.setValueAtTime(0.1, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.2);
        osc.connect(g); g.connect(ac.destination); osc.start(t); osc.stop(t+0.2);
    }
    else if(type==='impact') { 
        osc.frequency.setValueAtTime(100, t); osc.frequency.exponentialRampToValueAtTime(20, t+1);
        g.gain.setValueAtTime(0.8, t); g.gain.linearRampToValueAtTime(0, t+1);
        osc.connect(g); g.connect(ac.destination); osc.start(t); osc.stop(t+1.5);
    }
    else if(type==='miss') { 
        const buf = ac.createBuffer(1, ac.sampleRate*0.5, ac.sampleRate);
        const d = buf.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=Math.random()*2-1;
        const src = ac.createBufferSource(); src.buffer = buf;
        const f = ac.createBiquadFilter(); f.type='highpass'; f.frequency.value=1000;
        g.gain.setValueAtTime(0.1, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.3);
        src.connect(f); f.connect(g); g.connect(ac.destination); src.start(t);
    }
    else if(type==='gasp') {
        const buf = ac.createBuffer(1, ac.sampleRate, ac.sampleRate);
        const d = buf.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=Math.random()*2-1;
        const src = ac.createBufferSource(); src.buffer = buf;
        const f = ac.createBiquadFilter(); f.type='bandpass'; f.frequency.value=400;
        g.gain.setValueAtTime(0.3,t); g.gain.linearRampToValueAtTime(0,t+0.5);
        src.connect(f); f.connect(g); g.connect(ac.destination); src.start(t);
    }
    else if(type==='ricochet') {
        osc.type='sawtooth';
        osc.frequency.setValueAtTime(600,t); osc.frequency.linearRampToValueAtTime(200,t+0.3);
        g.gain.setValueAtTime(0.2,t); g.gain.exponentialRampToValueAtTime(0.01,t+0.3);
        osc.connect(g); g.connect(ac.destination); osc.start(t); osc.stop(t+0.3);
    }
    else if(type==='crack') {
        // Heavy glass crack sound
        const buf = ac.createBuffer(1, ac.sampleRate*0.5, ac.sampleRate);
        const d = buf.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=(Math.random()*2-1) * Math.exp(-i/(ac.sampleRate*0.1));
        const src = ac.createBufferSource(); src.buffer = buf;
        const f = ac.createBiquadFilter(); f.type='highpass'; f.frequency.value=800;
        
        g.gain.setValueAtTime(0.8,t); g.gain.exponentialRampToValueAtTime(0.01,t+0.4);
        src.connect(f); f.connect(g); g.connect(ac.destination); src.start(t);
        
        // Add a high pitched 'tink'
        const osc2 = ac.createOscillator(); osc2.frequency.value = 4000;
        const g2 = ac.createGain(); g2.gain.setValueAtTime(0.1, t); g2.gain.exponentialRampToValueAtTime(0.001, t+0.1);
        osc2.connect(g2); g2.connect(ac.destination); osc2.start(t); osc2.stop(t+0.1);
    }
    else if(type==='thunder') {
        const buf = ac.createBuffer(1, ac.sampleRate*2, ac.sampleRate);
        const d = buf.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=Math.random()*2-1;
        const src = ac.createBufferSource(); src.buffer = buf;
        const f = ac.createBiquadFilter(); f.type='lowpass'; f.frequency.value=200;
        g.gain.setValueAtTime(0.8,t); g.gain.exponentialRampToValueAtTime(0.01,t+1.5);
        src.connect(f); f.connect(g); g.connect(ac.destination); src.start(t);
    }
}

function playAmbience(isStorm) {
    if(!ac) return;
    if(amb) { amb.stop(); amb=null; }
    const buf = ac.createBuffer(1, ac.sampleRate*2, ac.sampleRate);
    const d = buf.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=Math.random()*2-1;
    const src = ac.createBufferSource(); src.buffer = buf; src.loop = true;
    const f = ac.createBiquadFilter(); f.type='lowpass'; f.frequency.value=isStorm?500:200;
    ambGain = ac.createGain(); ambGain.gain.value = isStorm?0.15:0.03;
    src.connect(f); f.connect(ambGain); ambGain.connect(ac.destination); src.start();
    amb = src;
}

function toggleAmbience(on) {
    if(!ambGain) return;
    const val = on ? (levelData.type==='storm'?0.15:0.03) : 0.005;
    ambGain.gain.setTargetAtTime(val, ac.currentTime, 0.2);
}

ui.showBriefing(0);

</script>
</body>
</html>
